# Graphite_server

Это серверная часть приложения Graphite. Более подробно о нем я рассказываю [в репозитории клиентской части](https://github.com/SergeyLebidko/graphite_client/blob/master/README.md). Здесь я ограничусь кратким описанием особенностей серверной части.

Серверная часть написана на Django. Для обработки запросов к api использован Django Rest Framework. 

Для обработки CORS я применил пакет django-cors-headers.
В файл settings.py помимо стандартных для django настроек также добавлены и настройки для CORS, требуемые этим пакетом:
```python
CORS_ORIGIN_WHITELIST = ['http://localhost:3000', 'http://127.0.0.1:3000', 'http://127.0.0.1', 'http://localhost']
```
Естественно, при развертывании проекта для работы на реальном сервере эти настройки должны быть изменены на адрес (или адреса) реального размещения фронтэнд-части проекта.

Также в проекте я не использую стандартную систему работы с пользователями, предлагаемую Django (за исключением, конечно, создания суперпользователя для доступа к админке). 
Для хранения сведений о клиентах я написал свою модель - Account и дополнительную модель - Token - для отслеживания пользовательских сессий.
Работает механизм довольно просто: при регистрации нового пользователя или при выполнении входа ранее уже зарегистрированного генерируется новый токен, который отправлется браузеру пользователя. Браузер сохраняет токен в local storage и в дальнейшем использует его для выполнения запросов к api, требующих обязательной авторизации. При выполнении выхода из аккаунта (через соответствующих хук) текущий токен удаляется. Также предусмотрен хук для выхода одновременно на всех устройствах, на которых был до этого залогинен пользователь (хук для этого производит удаление всех токенов, связанных с данным пользователем в результате чего токены, сохраненные на устройствах станут недействительными и выполоняемые с их помощью запросы будут отклняться со статусом 403 Forbidden).

В файле settings.py предусмотрена настройка для установки длины токена:
```python
ACCOUNT_TOKEN_SIZE = 32
```

Аутентификация пользователя по токену производится автоматически с помощью простой middleware-функции, которая просматривает заголовок Authorization в запросе, извлекает из него токен и ищет в БД ассоцированного с токеном пользователя. Если пользователь найден, то в объекте запроса (request) создается поле account со ссылкой на найденного пользователя. Если пользователь не найден (например, токен недействителен или отсутствует), то поле account получает значение None.

Так как я запускал и тестировал проект на локальной машине, на которой сетевые запросы выполняются мгновенно, мне хотелось как-то имитировать сетевые задержки, неизбежно возникающие при работе в реальной сети с медленными каналами. Для этого я написал небольшой middleware-класс LagMiddleware. Если проект находится в тестовом режиме (```DEBUG = True```), то данный класс вносит небольшую задержку в выполнение каждого сетевого запроса. Величина задержки в секундах указывается в settings.py в параметре LAG (я установил 0,5 сек.).

Если параметр DEBUG равен False, то задержка игнорируется.

И в заключение.
В репозитории находится БД, наполненная тестовыми данными (пользователи, посты, комментарии, лайки и т.д.). Создан суперпользователь. Данные суперпользователя:
Логин: admin
Пароль: Rd368446
